import logging
from telegram import Update, ChatMember
from telegram.ext import Application, CommandHandler, ChatMemberHandler, ContextTypes
from telegram.constants import ChatMemberStatus
import os
from datetime import datetime

def keep_alive():
    """Keep the service awake on Render free tier"""
    while True:
        try:
            # This will be your Render URL
            time.sleep(300)  # Wait 5 minutes
        except:
            pass

# Start keep-alive in background
threading.Thread(target=keep_alive, daemon=True).start()

# Enable logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# Bot configuration
BOT_TOKEN = os.getenv('BOT_TOKEN')
ADMIN_USER_IDS = [1925310270, 7137261147]  # PyaePPZ and shaneswa admin IDs
ADMIN_USERNAMES = ["PyaePPZ", "shaneswa"]  # Admin usernames for reference

class SecurityBot:
    def __init__(self):
        self.application = Application.builder().token(BOT_TOKEN).build()
        self.setup_handlers()
    
    def setup_handlers(self):
        # Command handlers
        self.application.add_handler(CommandHandler("start", self.start))
        self.application.add_handler(CommandHandler("help", self.help_command))
        self.application.add_handler(CommandHandler("ban", self.ban_user))
        self.application.add_handler(CommandHandler("unban", self.unban_user))
        self.application.add_handler(CommandHandler("kick", self.kick_user))
        self.application.add_handler(CommandHandler("status", self.group_status))
        
        # Chat member handler for tracking joins/leaves
        self.application.add_handler(ChatMemberHandler(self.track_chats, ChatMemberHandler.CHAT_MEMBER))
    
    async def start(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Send a message when the command /start is issued."""
        welcome_message = """
üîí **Security Bot Activated**

I'm now monitoring this group for member changes and providing admin controls.

**Available Commands:**
‚Ä¢ `/ban @username` - Ban a user from the group
‚Ä¢ `/unban @username` - Unban a user
‚Ä¢ `/kick @username` - Kick a user (they can rejoin)
‚Ä¢ `/status` - Show group statistics
‚Ä¢ `/help` - Show this help message

**Auto-notifications:**
‚úÖ User joins will be logged
‚ùå User leaves will be logged
üö´ Kicked/banned users will be logged

Only group admins can use moderation commands.
        """
        await update.message.reply_text(welcome_message, parse_mode='Markdown')
    
    async def help_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Send help message."""
        help_text = """
üîí **Smile Coin Security Bot**

ü§ñ **·Äò·Ä¨·Äê·ÄΩ·Ä±·Äú·ÄØ·Äï·Ä∫·Äï·Ä±·Ä∏·Äî·Ä≠·ÄØ·ÄÑ·Ä∫·Äú·Ä≤:**
‚Ä¢ ·Ä°·Äñ·ÄΩ·Ä≤·Ä∑·Äù·ÄÑ·Ä∫·Ä°·Äû·ÄÖ·Ä∫·Äê·ÄΩ·Ä± ·Äù·ÄÑ·Ä∫·Äú·Ä¨·Äõ·ÄÑ·Ä∫ ·ÄÄ·Äº·Ä≠·ÄØ·ÄÜ·Ä≠·ÄØ·Äô·Äö·Ä∫
‚Ä¢ ·Ä°·Äñ·ÄΩ·Ä≤·Ä∑·Äù·ÄÑ·Ä∫·Äê·ÄΩ·Ä± ·Äë·ÄΩ·ÄÄ·Ä∫·Äû·ÄΩ·Ä¨·Ä∏·Äõ·ÄÑ·Ä∫ ·Äî·Äæ·ÄØ·Äê·Ä∫·ÄÜ·ÄÄ·Ä∫·Äô·Äö·Ä∫
‚Ä¢ ·Ä°·Äñ·ÄΩ·Ä≤·Ä∑·Ä°·ÄÅ·Äª·ÄÄ·Ä∫·Ä°·Äú·ÄÄ·Ä∫·Äê·ÄΩ·Ä± ·Äï·Äº·Äï·Ä±·Ä∏·Äô·Äö·Ä∫
‚Ä¢ ·Äú·ÄØ·Ä∂·ÄÅ·Äº·ÄØ·Ä∂·Äõ·Ä±·Ä∏ ·ÄÖ·Ä±·Ä¨·ÄÑ·Ä∑·Ä∫·ÄÄ·Äº·Ää·Ä∑·Ä∫·Äï·Ä±·Ä∏·Äô·Äö·Ä∫

üìã **Available Commands:**
‚Ä¢ `/help` - ·Äí·ÄÆ·Äô·ÄÄ·Ä∫·ÄÜ·Ä±·Ä∑·ÄÅ·Äª·Ä∫·ÄÄ·Ä≠·ÄØ ·Äï·Äº·Äî·Ä∫·Äï·Äº·Äô·Äö·Ä∫
‚Ä¢ `/status` - ·Ä°·Äñ·ÄΩ·Ä≤·Ä∑·Ä°·ÄÅ·Äª·ÄÄ·Ä∫·Ä°·Äú·ÄÄ·Ä∫ ·ÄÄ·Äº·Ää·Ä∑·Ä∫·Äô·Äö·Ä∫

üõ°Ô∏è **·Ä°·ÄÑ·Ä∫·Äπ·ÄÇ·Ä´·Äõ·Äï·Ä∫·Äô·Äª·Ä¨·Ä∏:**
‚Ä¢ 24/7 ·Ä°·Äú·Ä≠·ÄØ·Ä°·Äú·Äª·Ä±·Ä¨·ÄÄ·Ä∫ ·ÄÖ·Ä±·Ä¨·ÄÑ·Ä∑·Ä∫·ÄÄ·Äº·Ää·Ä∑·Ä∫·ÄÅ·Äº·ÄÑ·Ä∫·Ä∏
‚Ä¢ ·Ä°·Äñ·ÄΩ·Ä≤·Ä∑·Äù·ÄÑ·Ä∫·Äô·Äª·Ä¨·Ä∏ ·Äù·ÄÑ·Ä∫·Äë·ÄΩ·ÄÄ·Ä∫·ÄÅ·Äº·ÄÑ·Ä∫·Ä∏ ·Äô·Äæ·Äê·Ä∫·Äê·Äô·Ä∫·Ä∏
‚Ä¢ ·Äú·ÄØ·Ä∂·ÄÅ·Äº·ÄØ·Ä∂·Äû·Ä±·Ä¨ ·Ä°·Äñ·ÄΩ·Ä≤·Ä∑·Äï·Äê·Ä∫·Äù·Äî·Ä∫·Ä∏·ÄÄ·Äª·ÄÑ·Ä∫

üíé **Smile Coin by Pyae** ·Äô·Äæ ·Äú·ÄØ·Ä∂·ÄÅ·Äº·ÄØ·Ä∂·Äõ·Ä±·Ä∏·ÄÄ·Ä≠·ÄØ ·ÄÖ·Ä±·Ä¨·ÄÑ·Ä∑·Ä∫·Äõ·Äæ·Ä±·Ä¨·ÄÄ·Ä∫·Äï·Ä´·Äê·Äö·Ä∫! 

üôã‚Äç‚ôÇÔ∏è ·Äô·Ä±·Ä∏·ÄÅ·ÄΩ·Äî·Ä∫·Ä∏·Äõ·Äæ·Ä≠·Äõ·ÄÑ·Ä∫ admin ·Äê·ÄΩ·Ä±·ÄÄ·Ä≠·ÄØ ·ÄÜ·ÄÄ·Ä∫·Äû·ÄΩ·Äö·Ä∫·Äï·Ä´

üëë Admins:
- @PyaePPZ - Main Admin
- @shaneswa - Co-Admin
        """
        await update.message.reply_text(help_text)
    
    async def is_admin(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> bool:
        """Check if user is admin of the group or in admin list."""
        user_id = update.effective_user.id
        username = update.effective_user.username
        chat_id = update.effective_chat.id
        
        # Check if user is in predefined admin list
        if user_id in ADMIN_USER_IDS or (username and username in ADMIN_USERNAMES):
            return True
        
        try:
            member = await context.bot.get_chat_member(chat_id, user_id)
            return member.status in [ChatMemberStatus.ADMINISTRATOR, ChatMemberStatus.CREATOR]
        except Exception as e:
            logger.error(f"Error checking admin status: {e}")
            return False
    
    async def ban_user(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Ban a user from the group."""
        if not await self.is_admin(update, context):
            await update.message.reply_text("‚ùå Only group administrators can use this command.")
            return
        
        target_user = None
        reason = "No reason provided"
        
        # Check if replying to a message
        if update.message.reply_to_message:
            target_user = update.message.reply_to_message.from_user
            reason = " ".join(context.args) if context.args else "No reason provided"
        else:
            # Parse arguments
            if not context.args:
                await update.message.reply_text("‚ùå Please specify a user to ban.\nUsage: `/ban @username` or reply to a message with `/ban`", parse_mode='Markdown')
                return
            
            username = context.args[0].replace('@', '')
            reason = " ".join(context.args[1:]) if len(context.args) > 1 else "No reason provided"
            
            # Try to find user by username
            try:
                # This is a simplified approach - in practice, you'd need to maintain a user database
                await update.message.reply_text("‚ùå Please reply to a user's message or provide their user ID instead of username.")
                return
            except Exception:
                await update.message.reply_text("‚ùå User not found.")
                return
        
        if target_user:
            try:
                await context.bot.ban_chat_member(update.effective_chat.id, target_user.id)
                
                ban_message = f"""
üö´ **User Banned**
üë§ User: {target_user.full_name} (@{target_user.username or 'No username'})
üÜî ID: `{target_user.id}`
üëÆ Banned by: {update.effective_user.full_name}
üìù Reason: {reason}
‚è∞ Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
                """
                await update.message.reply_text(ban_message, parse_mode='Markdown')
                
            except Exception as e:
                await update.message.reply_text(f"‚ùå Failed to ban user: {str(e)}")
    
    async def unban_user(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Unban a user from the group."""
        if not await self.is_admin(update, context):
            await update.message.reply_text("‚ùå Only group administrators can use this command.")
            return
        
        if not context.args:
            await update.message.reply_text("‚ùå Please specify a user ID to unban.\nUsage: `/unban 123456789`", parse_mode='Markdown')
            return
        
        try:
            user_id = int(context.args[0])
            await context.bot.unban_chat_member(update.effective_chat.id, user_id)
            
            unban_message = f"""
‚úÖ **User Unbanned**
üÜî User ID: `{user_id}`
üëÆ Unbanned by: {update.effective_user.full_name}
‚è∞ Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
            """
            await update.message.reply_text(unban_message, parse_mode='Markdown')
            
        except ValueError:
            await update.message.reply_text("‚ùå Please provide a valid user ID.")
        except Exception as e:
            await update.message.reply_text(f"‚ùå Failed to unban user: {str(e)}")
    
    async def kick_user(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Kick a user from the group."""
        if not await self.is_admin(update, context):
            await update.message.reply_text("‚ùå Only group administrators can use this command.")
            return
        
        target_user = None
        reason = "No reason provided"
        
        # Check if replying to a message
        if update.message.reply_to_message:
            target_user = update.message.reply_to_message.from_user
            reason = " ".join(context.args) if context.args else "No reason provided"
        else:
            if not context.args:
                await update.message.reply_text("‚ùå Please specify a user to kick.\nUsage: `/kick @username` or reply to a message with `/kick`", parse_mode='Markdown')
                return
            
            try:
                user_id = int(context.args[0])
                # In a real implementation, you'd need to get user info
                reason = " ".join(context.args[1:]) if len(context.args) > 1 else "No reason provided"
            except ValueError:
                await update.message.reply_text("‚ùå Please provide a valid user ID or reply to a message.")
                return
        
        if target_user:
            try:
                # Kick user (ban then unban to allow rejoining)
                await context.bot.ban_chat_member(update.effective_chat.id, target_user.id)
                await context.bot.unban_chat_member(update.effective_chat.id, target_user.id)
                
                kick_message = f"""
üë¢ **User Kicked**
üë§ User: {target_user.full_name} (@{target_user.username or 'No username'})
üÜî ID: `{target_user.id}`
üëÆ Kicked by: {update.effective_user.full_name}
üìù Reason: {reason}
‚è∞ Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
                """
                await update.message.reply_text(kick_message, parse_mode='Markdown')
                
            except Exception as e:
                await update.message.reply_text(f"‚ùå Failed to kick user: {str(e)}")
    
    async def group_status(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Show group statistics."""
        try:
            chat = await context.bot.get_chat(update.effective_chat.id)
            member_count = await context.bot.get_chat_member_count(update.effective_chat.id)
            
            status_message = f"""
üìä **Group Status**
üè∑Ô∏è Group: {chat.title}
üë• Members: {member_count}
üÜî Chat ID: `{chat.id}`
üìÖ Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

üîí Security Bot: Active ‚úÖ
üìù Monitoring: Joins/Leaves ‚úÖ
üëÆ Admin Controls: Available ‚úÖ
            """
            await update.message.reply_text(status_message, parse_mode='Markdown')
            
        except Exception as e:
            await update.message.reply_text(f"‚ùå Error getting group status: {str(e)}")
    
    async def track_chats(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Track when users join or leave the chat."""
        result = self.extract_status_change(update.chat_member)
        
        if result is None:
            return
        
        was_member, is_member = result
        user = update.chat_member.new_chat_member.user
        chat = update.effective_chat
        
        # User joined
        if not was_member and is_member:
            join_message = f"""
üéâ ·Äô·ÄÑ·Ä∫·Äπ·ÄÄ·Äú·Ä¨·Äï·Ä´ {user.full_name} üòä

üí∞ Smile Coin Selling by Pyae ·Äô·Äæ ·Äî·ÄΩ·Ä±·Ä∏·Äë·ÄΩ·Ä±·Ä∏·ÄÖ·ÄΩ·Ä¨ ·ÄÄ·Äº·Ä≠·ÄØ·ÄÜ·Ä≠·ÄØ·Äï·Ä´·Äê·Äö·Ä∫! ü§ó

üåü ·Äû·ÄÑ·Ä∫·Äü·Ä¨ ·ÄÄ·Äª·ÄΩ·Äî·Ä∫·Äê·Ä±·Ä¨·Ä∫·Äê·Ä≠·ÄØ·Ä∑·Äõ·Ä≤·Ä∑ ·Ä°·Äë·Ä∞·Ä∏·Äô·Ä≠·Äû·Ä¨·Ä∏·ÄÖ·ÄØ·Äù·ÄÑ·Ä∫ ·Äñ·Äº·ÄÖ·Ä∫·Äú·Ä¨·Äï·Ä´·Äï·Äº·ÄÆ! 
üíé ·Äí·ÄÆ·Äô·Äæ·Ä¨ ·Äê·ÄÄ·Äö·Ä∫·Äú·Ä≠·ÄØ·Ä∑ Smile Coin ·Ä°·ÄÄ·Äº·Ä±·Ä¨·ÄÑ·Ä∫·Ä∏ ·Äû·Ä≠·ÄÅ·Äª·ÄÑ·Ä∫·Äõ·ÄÑ·Ä∫ ·Äú·ÄΩ·Äê·Ä∫·Äú·Äï·Ä∫·ÄÖ·ÄΩ·Ä¨ ·Äô·Ä±·Ä∏·Äô·Äº·Äî·Ä∫·Ä∏·Äî·Ä≠·ÄØ·ÄÑ·Ä∫·Äï·Ä´·Äê·Äö·Ä∫
üìà ·ÄÄ·Äª·ÄΩ·Äî·Ä∫·Äê·Ä±·Ä¨·Ä∫·Äê·Ä≠·ÄØ·Ä∑ ·Ä°·Äê·Ä∞·Äê·Ä∞ ·Ä°·Ä±·Ä¨·ÄÑ·Ä∫·Äô·Äº·ÄÑ·Ä∫·ÄÄ·Äº·Ää·Ä∫·Ää·Ä≠·ÄØ·Äô·Äæ·ÄØ·Äõ·Ä≤·Ä∑ ·ÄÅ·Äõ·ÄÆ·Ä∏·ÄÄ·Ä≠·ÄØ ·ÄÖ·Äê·ÄÑ·Ä∫·ÄÄ·Äº·Äï·Ä´·ÄÖ·Ä≠·ÄØ·Ä∑! üöÄ

üë§ ·Ä°·Äô·Ää·Ä∫: {user.full_name}
üë§ Username: @{user.username or '·Äô·Äõ·Äæ·Ä≠·Äï·Ä´'}
üÜî ID: `{user.id}`
‚è∞ ·Ä°·ÄÅ·Äª·Ä≠·Äî·Ä∫: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

üéä ·ÄÄ·Äº·Ä≠·ÄØ·ÄÜ·Ä≠·ÄØ·Äï·Ä´·Äê·Äö·Ä∫·Äî·Ä±·Ä¨·Ä∫! Welcome to our family! üéä
            """
            await context.bot.send_message(chat.id, join_message, parse_mode='Markdown')
        
        # User left
        elif was_member and not is_member:
            leave_message = f"""
üòî ·Äî·ÄΩ·Ä±·Ä∏·Äî·Ä∞·Ä∏·Äê·Äö·Ä∫...

üëã {user.full_name} ·ÄÄ·Ä≠·ÄØ ·Äî·Äô·Ä∫·Ä∏·Äî·Ä±·Äï·Ä´·Äï·Äº·ÄÆ üò¢

üíî Smile Coin Selling by Pyae ·Äô·Äæ ·Äî·Äæ·ÄØ·Äê·Ä∫·ÄÜ·ÄÄ·Ä∫·Äï·Ä´·Äê·Äö·Ä∫...
üôè ·Äû·ÄÑ·Ä∫·Äî·Ä≤·Ä∑ ·Ä°·Äê·Ä∞·Äê·Ä∞ ·Äõ·Äæ·Ä≠·ÄÅ·Ä≤·Ä∑·Äõ·Äê·Ä¨ ·Äù·Äô·Ä∫·Ä∏·Äû·Ä¨·Äï·Ä´·Äê·Äö·Ä∫
üåü ·Äî·Ä±·Ä¨·ÄÑ·Ä∫·Äê·ÄÅ·Äª·Ä≠·Äî·Ä∫·Äô·Äæ·Ä¨ ·Äï·Äº·Äî·Ä∫·Äú·Ä¨·ÄÅ·Ä≤·Ä∑·Äï·Ä´·Ä¶·Ä∏·Äî·Ä±·Ä¨·Ä∫
üíù ·Äû·ÄÑ·Ä∑·Ä∫·Ä°·Äê·ÄΩ·ÄÄ·Ä∫ ·Äê·Ä∂·ÄÅ·Ä´·Ä∏·ÄÄ·Ä≠·ÄØ ·Ä°·Äô·Äº·Ä≤·Äñ·ÄΩ·ÄÑ·Ä∑·Ä∫·Äë·Ä¨·Ä∏·Äï·Ä´·Äô·Äö·Ä∫

üë§ ·Ä°·Äô·Ää·Ä∫: {user.full_name}
üë§ Username: @{user.username or '·Äô·Äõ·Äæ·Ä≠·Äï·Ä´'}
üÜî ID: `{user.id}`
‚è∞ ·Ä°·ÄÅ·Äª·Ä≠·Äî·Ä∫: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

üòä ·ÄÄ·Ä±·Ä¨·ÄÑ·Ä∫·Ä∏·Äô·ÄΩ·Äî·Ä∫·Äï·Ä´·ÄÖ·Ä±! Take care! üåà
            """
            await context.bot.send_message(chat.id, leave_message, parse_mode='Markdown')
    
    def extract_status_change(self, chat_member_update):
        """Extract whether the 'old_chat_member' was a member and whether the 'new_chat_member' is a member."""
        status_change = chat_member_update.difference().get("status")
        old_is_member, new_is_member = chat_member_update.difference().get("is_member", (None, None))
        
        if status_change is None:
            return None
        
        old_status, new_status = status_change
        was_member = old_status in [
            ChatMemberStatus.MEMBER,
            ChatMemberStatus.CREATOR,
            ChatMemberStatus.ADMINISTRATOR,
        ] or (old_status == ChatMemberStatus.RESTRICTED and old_is_member is True)
        
        is_member = new_status in [
            ChatMemberStatus.MEMBER,
            ChatMemberStatus.CREATOR,
            ChatMemberStatus.ADMINISTRATOR,
        ] or (new_status == ChatMemberStatus.RESTRICTED and new_is_member is True)
        
        return was_member, is_member
    
    def run(self):
        """Start the bot."""
        print("üîí Security Bot starting...")
        print("Bot is now running. Press Ctrl+C to stop.")
        self.application.run_polling(allowed_updates=Update.ALL_TYPES)

def main():
    """Main function to run the bot."""
    if BOT_TOKEN == "YOUR_BOT_TOKEN_HERE":
        print("‚ùå Please set your bot token in the BOT_TOKEN variable!")
        print("Get your token from @BotFather on Telegram")
        return
    
    bot = SecurityBot()
    bot.run()

if __name__ == '__main__':
    main()
